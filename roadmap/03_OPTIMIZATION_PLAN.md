# NanoKVM Cube — План оптимизации

Дата: 2026-02-17
Версия: 1.0

---

## Приоритеты (от высшего к низшему)

Фиксы упорядочены по формуле: видимый импакт × обратная сложность. Первые пункты дают максимальный результат при минимальных усилиях.

---

## FIX-1: Исправить конфигурацию GOP/IDR в VENC

Связанная проблема: P1 (H.264 периодические фризы).
Импакт: высочайший — полностью устраняет 10-секундный цикл фризов, делает H.264 режим пригодным к использованию.
Сложность: средняя — требуется модификация C-кода в components/kvm_mmf/.
Время реализации: 2-4 часа при наличии среды сборки.

Что делать:
- Уменьшить GOP size с текущего значения (предположительно 300) до 30-60 кадров. При 30fps это IDR каждые 1-2 секунды. При потере IDR браузер восстановится через 1-2 сек вместо 10.
- Вызывать CVI_VENC_RequestIDR() при подключении нового клиента — чтобы клиент не ждал до следующего естественного IDR.
- Использовать Baseline Profile без B-кадров — упрощает декодирование на стороне браузера, убирает необходимость реордеринга кадров.
- Опционально: добавить адаптивную вставку IDR при обнаружении значительного изменения сцены.

Где менять код: NanoKVM-System/components/kvm_mmf/ — найти инициализацию VENC_CHN_ATTR_S или аналогичной структуры, изменить u32Gop или эквивалентное поле. Найти вызов CVI_VENC_CreateChn и параметры перед ним.

Побочные эффекты: уменьшение GOP увеличивает bitrate на 10-20% (больше IDR-кадров = больше данных). При H.264 на 100 Mbps это не проблема — 4-15 Mbps с запасом помещаются в канал.

---

## FIX-2: Отключить USB wakeup spam

Связанная проблема: P4 (USB Gadget wakeup spam).
Импакт: средний — освобождает CPU от сотен лишних прерываний в секунду.
Сложность: минимальная — одна команда.
Время реализации: 5 минут.

Что делать: добавить в init-скрипт S03usbdev строку: echo disabled > /sys/bus/platform/drivers/dwc2/4340000.usb/power/wakeup. Альтернативно, выполнить однократно через SSH для проверки эффекта.

Где менять код: kvmapp/system/init.d/S03usbdev — добавить после инициализации USB gadget.

Верификация: выполнить dmesg | grep -c "signalling skipped" до и после. Должно упасть до нуля.

Побочные эффекты: отключение USB wakeup может повлиять на выход хоста из sleep-режима через USB. Для KVM-сценария это обычно неактуально — хост управляется через ATX power control.

---

## FIX-3: Откатить или сделать условным буферизацию H.264 Direct из v2.2.8

Связанная проблема: P2 (регрессия v2.2.7→v2.2.8).
Импакт: высокий — восстанавливает отзывчивость H.264 Direct до уровня v2.2.7.
Сложность: средняя — требуется анализ diff между v2.2.7 и v2.2.8 в server/service/ и web/src/.
Время реализации: 2-6 часов.

Что делать:
- Сделать буферизацию для фоновых вкладок условной: включать только когда страница реально в фоне (Page Visibility API: document.hidden === true).
- Для активной вкладки использовать прямой путь без дополнительной буферизации — как было в v2.2.7.
- Устранить лишнее копирование кадров, введённое рефакторингом.

Где менять код: NanoKVM/server/service/ — логика H.264 Direct стриминга. NanoKVM/web/src/ — MediaSource API буферизация.

---

## FIX-4: Настроить GOGC и GOMEMLIMIT

Связанная проблема: P7 (Go Runtime memory pressure).
Импакт: средний — сокращает длительность GC пауз.
Сложность: минимальная — переменные окружения.
Время реализации: 2 минуты на тест.

Что делать:
- Установить GOGC=50 (по умолчанию 100). GC будет запускаться чаще, но каждый цикл будет короче — менее заметные паузы.
- Установить GOMEMLIMIT=30MiB — жёсткий лимит потребления Go heap, при приближении к лимиту GC становится агрессивнее.
- Использовать sync.Pool для буферов кадров вместо make([]byte, frameSize) на каждый кадр — снижает давление на аллокатор и GC.

Где менять: в скрипте запуска S95nanokvm или в обёртке запуска NanoKVM-Server — добавить переменные окружения GOGC=50 GOMEMLIMIT=30MiB перед запуском бинарника.

Верификация: замерить GC паузы до и после через GODEBUG=gctrace=1.

---

## FIX-5: Заменить CGO на shared memory (mmap) или unix socket

Связанная проблема: P3 (CGO overhead).
Импакт: средний — убирает 30 переключений стека в секунду, экономит 1.5-3 мс/сек.
Сложность: высокая — требуется модификация и C, и Go кода.
Время реализации: 1-3 дня.

Вариант A — shared memory/mmap: libkvm_mmf.so записывает закодированные кадры в ring buffer в shared memory. Go читает кадры через mmap. Ноль CGO-вызовов на видео-пути. Синхронизация через eventfd или futex.

Вариант B — unix socket: libkvm_mmf.so отправляет закодированные кадры через unix domain socket. Go читает из сокета стандартным net.Conn. Проще реализовать, чем shared memory. Overhead: один syscall read вместо CGO — значительно дешевле.

Вариант C — полная перезапись транспорта на Rust/C: убирает Go из data path полностью. libkvm_mmf.so → WebSocket/WebRTC сервер на Rust/C. Максимальный эффект, но максимальная сложность.

Где менять код: C-сторона — NanoKVM-System/components/kvm_mmf/ (добавить mmap/socket output). Go-сторона — NanoKVM/server/ (заменить CGO-вызовы на mmap/socket чтение).

---

## FIX-6: Снизить дефолтное разрешение до 720p

Связанная проблема: P5 (MJPEG чоппинг), общая оптимизация.
Импакт: средний — снижает нагрузку по всему пайплайну.
Сложность: минимальная — изменение одного файла.
Время реализации: 1 минута.

Что делать: установить дефолтное разрешение передачи 720p вместо 1080p. Для MJPEG это снижает bitrate с 50-80 Mbps до 15-25 Mbps. Для H.264 — с 4-15 Mbps до 2-8 Mbps.

Где менять: /kvmapp/kvm/res — записать "720" или эквивалентное значение.

---

## FIX-7: Оптимизировать WebRTC для LAN

Связанная проблема: P6 (WebRTC хуже WebSocket).
Импакт: средний — может сделать WebRTC основным режимом (UDP latency < TCP).
Сложность: средняя-высокая.
Время реализации: 1-2 дня.

Что делать:
- Уменьшить или отключить jitter buffer для LAN-подключений (RTT < 5 мс).
- Упростить ICE: при подключении из той же подсети — host candidate only, без STUN/TURN.
- Рассмотреть отключение WebRTC по умолчанию и использование H.264 Direct как primary — это проще и уже работает быстрее.

Где менять код: серверная часть WebRTC — NanoKVM/server/service/ (конфигурация pion/webrtc). Конфигурация STUN/TURN — /etc/kvm/server.yaml. Фронтенд — NanoKVM/web/src/ (RTCPeerConnection параметры).

---

## FIX-8: Улучшить frame difference detection

Связанная проблема: P8 (задержка при возобновлении).
Импакт: низкий — заметен только при частых паузах ввода.
Сложность: средняя.
Время реализации: несколько часов.

Что делать:
- При обнаружении первого изменения после паузы — немедленно вызвать CVI_VENC_RequestIDR() для мгновенной генерации кейфрейма.
- Отправить burst из 2-3 кадров с пониженным QP (высокое качество) для быстрого восстановления картинки.
- Если FIX-1 уже применён (GOP=30-60), эта проблема частично решается автоматически — ожидание IDR снижается с 10 сек до 1-2 сек.

Где менять код: NanoKVM-System/components/kvm_mmf/ (детекция изменений, вызов RequestIDR). NanoKVM/server/service/ (логика burst-отправки).

---

## Критический инсайт

Переписывание Go-бэкенда на Rust/C улучшит RAM (экономия 10-15 МБ) и устранит GC паузы, но не окажет значительного влияния на видеолатентность. Реальная работа — это исправление H.264 encoder bugs (GOP/IDR конфигурация) и оптимизация WebRTC транспорта в C/C++ мультимедийной подсистеме.

FIX-1 через FIX-3 — это работа с C-кодом (kvm_system, libkvm_mmf.so) и параметрами VENC, а не с Go-бэкендом. FIX-4 — единственная чистая Go-оптимизация. Именно первые три фикса определяют задержку видеопотока.
